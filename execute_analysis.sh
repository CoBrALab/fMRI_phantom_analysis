#!/bin/bash
#
# ARG_POSITIONAL_SINGLE([input_epi],[The phantom fMRI timeseries, as a 4D nifti.],[])
# ARG_OPTIONAL_SINGLE([output_path],[],[Prefix to the pdf and csv output files. Must not already exist.],[./fMRI_stability_report])
# ARG_OPTIONAL_SINGLE([repetition_time],[],[The acquisition TR, in seconds.],[1.0])
# ARG_OPTIONAL_SINGLE([roi_width],[],[Width of the ROI in which mean metric values are extracted, in voxels.],[10])
# ARG_OPTIONAL_SINGLE([input_roi],[],[A manually drawn single-slice ROI, as a 3D nifti. A 10x10 ROI in the center slice is used by default.],[None])
# ARG_OPTIONAL_SINGLE([desired_slice],[],[The slice to be plotted in the report, as an integer. Center slice is computed and used by default.],[None])
# ARG_OPTIONAL_SINGLE([weisskoff_max_roi_width],[],[The width of the largest ROI that is analyzed during Weisskoff analysis, in pixels. It should be as large as possible without extending outside the phantom],[20])
# ARG_OPTIONAL_SINGLE([longitudinal_csv],[],[Csv outputed during previous sessions. The new stability metrics will be appended to this csv, and an additional figure that compares the metrics across sessions will be included in the report.],[None])
# ARG_HELP([This script performs a temporal stability analysis of an fMRI timeseries acquired using a phantom. The outputs aid in the diagnosis of issues with scanner stability.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='h'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_output_path="./fMRI_stability_report"
_arg_repetition_time="1.0"
_arg_roi_width="10"
_arg_input_roi="None"
_arg_desired_slice="None"
_arg_weisskoff_max_roi_width="20"
_arg_longitudinal_csv="None"


print_help()
{
	printf '%s\n' "This script performs a temporal stability analysis of an fMRI timeseries acquired using a phantom. The outputs aid in the diagnosis of issues with scanner stability."
	printf 'Usage: %s [--output_path <arg>] [--repetition_time <arg>] [--roi_width <arg>] [--input_roi <arg>] [--desired_slice <arg>] [--weisskoff_max_roi_width <arg>] [--longitudinal_csv <arg>] [-h|--help] <input_epi>\n' "$0"
	printf '\t%s\n' "<input_epi>: The phantom fMRI timeseries, as a 4D nifti."
	printf '\t%s\n' "--output_path: Prefix to the pdf and csv output files. Must not already exist. (default: './fMRI_stability_report')"
	printf '\t%s\n' "--repetition_time: The acquisition TR, in seconds. (default: '1.0')"
	printf '\t%s\n' "--roi_width: Width of the ROI in which mean metric values are extracted, in voxels. (default: '10')"
	printf '\t%s\n' "--input_roi: A manually drawn single-slice ROI, as a 3D nifti. A 10x10 ROI in the center slice is used by default. (default: 'None')"
	printf '\t%s\n' "--desired_slice: The slice to be plotted in the report, as an integer. Center slice is computed and used by default. (default: 'None')"
	printf '\t%s\n' "--weisskoff_max_roi_width: The width of the largest ROI that is analyzed during Weisskoff analysis, in pixels. It should be as large as possible without extending outside the phantom (default: '20')"
	printf '\t%s\n' "--longitudinal_csv: Csv outputed during previous sessions. The new stability metrics will be appended to this csv, and an additional figure that compares the metrics across sessions will be included in the report. (default: 'None')"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			--output_path)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_output_path="$2"
				shift
				;;
			--output_path=*)
				_arg_output_path="${_key##--output_path=}"
				;;
			--repetition_time)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_repetition_time="$2"
				shift
				;;
			--repetition_time=*)
				_arg_repetition_time="${_key##--repetition_time=}"
				;;
			--roi_width)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_roi_width="$2"
				shift
				;;
			--roi_width=*)
				_arg_roi_width="${_key##--roi_width=}"
				;;
			--input_roi)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_input_roi="$2"
				shift
				;;
			--input_roi=*)
				_arg_input_roi="${_key##--input_roi=}"
				;;
			--desired_slice)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_desired_slice="$2"
				shift
				;;
			--desired_slice=*)
				_arg_desired_slice="${_key##--desired_slice=}"
				;;
			--weisskoff_max_roi_width)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_weisskoff_max_roi_width="$2"
				shift
				;;
			--weisskoff_max_roi_width=*)
				_arg_weisskoff_max_roi_width="${_key##--weisskoff_max_roi_width=}"
				;;
			--longitudinal_csv)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_longitudinal_csv="$2"
				shift
				;;
			--longitudinal_csv=*)
				_arg_longitudinal_csv="${_key##--longitudinal_csv=}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'input_epi'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_input_epi "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash


### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

################################################################# ACTUAL SCRIPT #################################################

source activate phantom_analysis
set -euo pipefail
IFS=$'\n\t'

# Manage output arguments
output_fname=$(basename -- "$_arg_output_path")
output_dirname=$(dirname -- "$_arg_output_path")
output_extension="${output_fname##*.}"
output_fname_prefix="${output_fname%.*}"

output_path_prefix="$output_dirname/$output_fname_prefix"
if [ -f "$output_path_prefix.pdf" ] || [ -f "$output_path_prefix.csv" ]; then
    die "Requested output already exists, aborting not to overwrite." 1
fi

#get the path to the folder where the current script is located
wdir="$PWD"; [ "$PWD" = "/" ] && wdir=""
case "$0" in
  /*) scriptdir="${0}";;
  *) scriptdir="$wdir/${0#./}";;
esac
scriptdir="${scriptdir%/*}"

python3.8 $scriptdir/phantom_analysis_functions.py $_arg_input_epi $output_path_prefix $_arg_repetition_time $_arg_roi_width $_arg_input_roi $_arg_desired_slice $_arg_weisskoff_max_roi_width $_arg_longitudinal_csv

# ] <-- needed because of Argbash
